(in-package :local-time-locale)

(defvar *parse-functions* (make-hash-table :test 'equal))

(defvar *hours* nil)
(defvar *minutes* nil)
(defvar *meridiem* nil)
(defvar *year* nil)
(defvar *month* nil)
(defvar *day* nil)

(defmacro define-parse-function (keys &body body)
  `(dolist (key ',keys)
     (setf (gethash key *parse-functions*)
	   (lambda (string)
	     ,@body))))

(defun %%read-next-integer (string min-chars max-chars)
  (multiple-value-bind (int index)
      (parse-integer string :junk-allowed t)
    (when (or (> index max-chars)
	      (< index min-chars))
      (parsing-error "Unable to find expected ~a to ~a digit number" min-chars max-chars))
    (values int (subseq string index) index)))

(define-parse-function ("h" "hh" "H" "HH")
  (multiple-value-bind (v rest)
      (%%read-next-integer string 1 2)
    (setf *hours* v)
    rest))

(define-parse-function ("mm")
  (multiple-value-bind (v rest)
      (%%read-next-integer string 2 2)
    (setf *minutes* v)
    rest))

(define-parse-function ("A")
  (let ((meridiems(meridiems *default-locale*)))
    (block party
      (dolist (m meridiems)
	(when (and (>= (length string) (length (first m)))
		   (string= (first m) (subseq string 0 (length (first m)))))
	  (setf *meridiem* (second m))
	  (return-from party (subseq string (length (first m))))))
      (parsing-error "Unable to find a usable meridiem"))))

(define-parse-function ("YYYY")
  (multiple-value-bind (v rest count)
      (%%read-next-integer string 1 4)
    (if (and (< v 1900)
	     (< count 4))
	(setf *year* (+ 1900 v))
	(setf *year* v))
    rest))

(define-parse-function ("M" "MM")
  (multiple-value-bind (v rest)
      (%%read-next-integer string 1 2)
    (setf *month* v)
    rest))

(define-parse-function ("D" "DD")
  (multiple-value-bind (v rest)
      (%%read-next-integer string 1 2)
    (setf *day* v)
    rest))

(define-parse-function ("." "/" "-")
  ;; we treat these three date seperators as equivilant
  (let ((first (subseq string 0 1)))
    (or (equal first ".")
	(equal first "/")
	(equal first "-")
	(parsing-error "Unable to find a valid date seperator"))
    (subseq string 1)))

(define-parse-function (" ")
  (let ((first (subseq string 0 1)))
    (or (equal first " ")
	(parsing-error "Unable to find expected space"))
    (subseq string 1)))

(defun parse-timestamp-from-format (string format &key (timezone local-time::*default-timezone*) (locale *default-locale*))
  (let* ((*default-locale* locale)
	 (tokens (ltl::%tokenize-format (ltl::expand-format format *default-locale* )))
	 (*hours*    0)
	 (*minutes*  0)
	 (*meridiem* nil)
	 (*year*     0)
	 (*month*    0)
	 (*day*      0))
    (dolist (token tokens)
      (when (string= string "") (parsing-error "Ran out of string to parse")) 
      (setf string (funcall (or (gethash token *parse-functions*)	
				(lambda (string) 
				  (let ((first (subseq string 0 1))
					(rest (subseq string 1)))
				    (or (string= token first)
					(parsing-error "No literal match"))
				    rest)))
			    string)))
    (unless (string= string "") (parsing-error "Still have string left over"))
    (when *meridiem*
      (setf *hours* (funcall *meridiem* *hours*)))
    (lt::encode-timestamp 0 0 *minutes* *hours* *day* *month* *year* :timezone timezone)))
		       
(defun parse-timestamp (string &key (timezone local-time::*default-timezone*) (locale *default-locale*))
  (dolist (f (timestamp-parsing-formats locale))
    (handler-case
	(progn
	  (return-from parse-timestamp (parse-timestamp-from-format string f :timezone timezone :locale locale)))
      (local-time-locale-error ()))
    (parsing-error "Failed to parse timestamp with any expected parsing formats")))

